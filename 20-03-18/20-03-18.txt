*LTS
Long-Term Service - 오래동안 서비스할 제품(잘 변하거나 없어지지 않으므로 주로 사용하기 좋다)

*Stable
안정적

*플랫폼 종속성
C->A플랫폼에서 실행시 컴파일 => B플랫폼에서 실행시 다시 컴파일 => C플랫폼에서 실행시 또 다시 컴파일
-컴파일된 실행파일이 플랫폼에 종속된다

JAVA->컴파일시 바이트코드 생성 ->A,B,C...모두 실행가능(단, 플랫폼에 모두 JVM-자바가상기계가 있어야 해석&실행가능)

C는 빠르지만(컴파일 한번으로 실행까지 가능) 플랫폼마다 새로 컴파일 해야된다
JAVA는 느리지만(컴파일 후 바이트코드 해석) 플랫폼마다 컴파일 할 필요없다

C/C++ 소스코드 -> 컴파일러/링커 -> 바이러니 실행 파일(test.exe) -> 운영체제에서 실행
JAVA 소스코드   -> 컴파일러       -> 바이트코드(test.class)  ->  자바가상기계 -> 운영체제에서 실행


*컴파일러 : 전체코드를 한꺼번에 번역
인터프리터 : 한줄씩(하나의 명령문씩 번역해서 실행)

*JDK와 JRE
JDK-자바 응용 개발 환경,개발 도구(bin파일에 들어있다)
JRE- 자바 실행 환경(JVM포함), 개발자가 아닌 자바 유저에게 필요(없으면 자바 파일이 실행이 안된다)

JAVA SE(Standard Edition) - 기본적인 에디션. 대부분 사용
JAVA EE(Enterprise Edition) - 기업용 에디션. 일부 기업만 사용
JAVA ME(Micero Edition) - 경량 에디션. 모바일기기. 현재 거의 사용 안함


*접근제한자
public : 외부로부터 접근 가능
private : 외부에서 접근 불가
protected : 자식에게 접근 허용


*oop에서는 원칙
1.Class를 먼저 생성
2.Class를 이용해서 instance를 생성
3.instance를 사용해서 함수호출, 변수 사용
(하지만 static은 instance 생성없이 실행메모리에 미리 올라가기 때문에 instance 없이 실행 가능)

*static : 메모리에 미리 준비되어 사용(실행) 가능하게 해줌-정적
ex)main함수는 프로그램 실행시 항상 준비되어 있어야하기 때문에 main은 항상 static으로 선언
public 'static' void main()


*자바 특징
★플랫폼 독립성	- 운영체제,플랫폼에 종속되지 않는다. JVM만 있으면 어디서든 실행 가능
객체 지향 	- 캡슐화,상속,다형성을 지원
클래스로 캡슐화 	- 클래스에 속하지 않는 변수나 메소드는 없다.
소스와 클래스파일 	- 클래스 파일에는 반드시 하나의 자바 클래스만 들어 있다. 
                           여러개의 클래스를 가진 소스 파일은 컴파일하면 클래스마다 별도의 클래스파일 생성
실행 코드 배포 	- 다수 클래스 파일을 jar파일 형태로 압축하여 배포 또는 실행
패키지 		- 관련된 클래스는 패키지로 묶어 관리
★멀티스레드 	- 다수의 작업을 처리할 수 있도록 다수의 스레드가 동시에 실행,동시접속사 처리에 유리
★가비지 콜렉터	- 사용되지 않고 숨어있는 메모리를 수집하여 소멸
★예외 처리	- 실행시 에러(Run Time Error)가 발생해도 예외 처리로 돌아가고
		   프로그램이 종료되지 않음(에러로 인한 종료가 없으므로 신뢰성이 높아진다)
실시간 부합	- 예측할 수 없는 시점에 GC가 실행되므로 프로그램 실행이 일시적으로 중단
JIT컴파일러	- JVM이 인터프리터(한줄씩 컴파일) 방식으로 바이트 코드를 실행하기 때문에 C보다 느림
		  최근에는 실행 도중 CPU의 기계어 코드로 컴파일,
		   CPU가 바로실행하는 JIT(Just in time)컴파일 기법 사용으로 비슷하도록 개선


java 코딩 순서
1.클래스 생성
2.인스턴스,레퍼런스 생성
3.생성된 인스턴스,레퍼런스 사용

*Circle pizza = new Circle();
-pizza : 레퍼런스(포인터 같은 역할)
-'new' : 메소드를 실행메모리에 생성(Circle()을)

*pizza.radius = 10;
-구조체 사용법과 비슷
구조체->발전->Class(둘의 모습이 비슷)

*식별자
클래스,변수,상수,메소드 등에 붙이는 이름
-'_','$'는 사용 가능,@#!같은 특수문자,공백 또는 탭은 식별자로 사용 불가
-자바는 유니코드 문자 사용 가능하지만 참조 받는 다른 프로그램이 인식하지 못할 수도 있으니
 한글은 안 쓰는게 더 좋다
-식별자의 첫번째 문자로 숫자는 사용불가
-'_' 또는 '$'를 식별자 첫 번째 문자로 사용할 수 있으나 일반적으로 잘 사용하지 않는다.
-불린 리터널(true,false)와 널 리터널(null)은 식별자로 사용불가
-길이 제한 없음

*식별자 붙이는 룰
-클래스 첫 문자와 각단어의 첫 문자는 대문자(카멜 표기법 ex-HelloWorld)
-변수의 첫 문자는 소문자
-상수는 모든 문자를 대문자로 표시


*자바의 데이터 타입
-char
-short
-int
-long
-float
-double
-byte
-boolean   :    true,false
외에는 거의 다 레퍼런스(포인터를 쉽게 쓰기 위해 만든 것)

배열(array)에 대한 레퍼런스
클래스(Class)에 대한 레퍼런스 , 인터페이스(interface)에 대한 레퍼런스  => instance

--------------------------------------------------------------------------------------------
Circle pizza;   		// instance명 선언. instance명은 참조변수
pizza = new Circle(); 	// Circle Object(instance)를 만든 후,
		    	   만들어진 Object를 가리키는 참조값을 pizza에 넣음
Circle pizza = new Circle();	// 선언과 동시에 생성.초기화

레퍼런스 변수는 C의 포인터와 같은 역할.
1.레퍼런스는 메모리 주소가 아닌 참조값을 저장. 간접 Access
2.레퍼런스는 포인터처럼 연산을 할 수 없다.
3.레퍼런스는 값이 없는 상태를 null로 표현.
4.클래스명 변수명; 으로 선언한 변수는 reference임


*String클래스로 문자열 표현
-문자열 리터럴 - "JDK","한글"
String toolName="JDK";

-문자열이 섞인 + 연산 -> 문자열 연결
toolName + 1.8 -> "JDK1.8"

*문자 리터널
'w','a','가',\u0041
-\u유니코드 값을 사용

*boolean타입
boolean a = true;
boolean b = 10>0;
boolean c= 1;	-오류. 자바는 c처럼 0과 1을 false,true로 사용 불가

*var 키워드
변수 타입 선언 생략 : 컴파일러가 변수 타입 추론
var price = 200;		-price는 int타입으로 결정
var name = "kitae";		-name은 String 타입으로 결정
var pi = 3.14;		-pi는 double타입으로 결정

but,
var name;		//오류! VAR키워드는 초기화가 필수

*상수 선언
final ~~
ex) final double PI = 3.14;


*자동 타입 변환(형변환)
-작은 타입->큰타입으로 자동 변환(ex short(+-약3만)=>int(+-약 22억)로 다 집어넣어도 오버플로우가 안난다)
long m = 25;		//리터럴 25는 int타입.25가 long타입으로 자동 변환
double d = 3.14+10;		//실수연산을 하기 위해 10이 10.0으로 자동 변환

*큰타입이 작은타입으로 변환할때(강제 타입 변환)
int n= 300;
byte b = n;	//오버플로우
byte b = (byte)n;	//강제 형변환(캐스팅-캐스트 연산자'()' 사용해서 형변환)


System.in에서 키를 읽게 하고, 읽은 바이트를 문자, 정수, 실수, 불린, 문자열등 다양한 타입으로 변환하여 리턴
-java.util.Scanner 클래스

*객체 생성
import java.util.Scanner; //import 문 필요
...
Scanner a = new scanner(System.in) // Scanner 객체 생성
-생성된 해당 scanner를 이용하여 입력


next()		-토큰을 문자열로 리턴
nextByte()		-토큰을 byte타입으로
nextShort()
nextInt()
nextLong()
nextFloat()
nextDouble()
nextBoolean()
String nextLine()	-\n을 포함하는 한 라인을 읽고 \n을 버린 나머지 문자열 리턴
void close()	-scanner 종료
boolean hasNext()	-현재입력된 토큰이 있으면 true,아니면 입력 때까지 대기. 새 입력이 들어올때 true리턴
		 ctrl-z키가 입력되면 입력 끝이므로 false


연산자
증감	 ++ --
산술 	+ - * / %
시프트	 >> << >>>
비교 	> < >= <= == !=
비트	& | ^ ~
논리 	&& || ! ^
조건	? :
대입 	= *= /=... <<= >>>=

거의 비슷하지만 시프트에 >>>와 대입 >>>=가 다르다


*3항 연산자
condition ? orp2 : orp3
ex) int s = (x>y) ? 1: -1;
x보다 y가 크다는 것이 참이면 1, 거짓이면 -1

시프트
-a>>b , a<<b, a>>>b
a>>b는 오른쪽으로 b만큼 시프트 최상위 빈자리는
 전의 최상위 비트(최상위 비트는 부호 비트,즉 +라면 그대로 +,-라면 그대로 -)

a<<b는 왼족으로 b만큼 시프트 최하위 빈자리는 0

a>>>b는 오른쪽을 b만큼 시프트 후 최상위 빈자리는 0
