*포인터의 연산
포인터 a+1은 주소값에 1을 더한 것이 아닌 배열의 다음칸의 주소를 가리킨다
	char형		int형		float형
a							배열 1번째칸 주소
a+1	a+1byte		a+4byte		a+8byte		배열 2번째칸 주소
a+2	a+1byte*2	a+4byte*2	a+8byte*2	배열 3번째칸 주소
a+3	a+3byte		a+12byte		a+24byte		배열 4번째칸 주소
a+i
배열 각 칸의 주소값을 나타내는 것은 &a[i]도 마찬가지이다.
※(a+i) == &a[i]

값을 나타내는 *포인터 역시 마찬가지

*a	배열 1번째칸 값
*(a+1)	배열 2번째칸 값		이때, 배열 값은 a[i]이다.
*(a+2)	배열 3번째칸 값		따라서 a[i] == *(a+i)
*(a+3)	배열 4번째칸 값
*(a+i)


*함수(Function)
함수_이름();
ex)printf();

자료형 함수명(매개변수 or 인수) -함수헤드
int coffee_machine(int button)
{
     내용
     return 0;	-반환값은 자료형에 맞게
}

함수 호출
int coffee;
int fun = coffee_machine(coffee);	-함수명을 불러서 호출한 후 매개변수(패러미터)를 넘겨준다.
main()		
  |
  |
  |      인수->	함수
호출============◎
  |       <리턴값
  |
 ↓
※리턴값은 함수를 호출한 그 자리로 반환된다.


함수 사용하는 이유
1. 코드의 재활용(중복되는 코드 감소,최적화)
2. 수정이 편리
3. 프로그램을 기능별로 나누어서 구현
입력, 계산, 출력, 하는 기능을 각각의 함수로 구현
=>module화(부품화) : 협업가능

※함수의 묶음 - Function Library(판매하기도 한다.)

지역변수&전역변수
함수 밖에서 선언된 변수는 프로그램 전체에서 사용되고 참조할 수 있다.(전역변수)
함수 안에서 선언된 변수는 해당 함수 안에서만 사용되고 참조될 수 있다.(지역변수)
*지역변수와 전역변수의 변수명은 같을 수 있지만 안에 담겨있는 메모리가 다르다.
*같은 변수명의 지역변수와 전역변수가 있다면 
지역변수가 선언된 함수는 지역변수가 우선순위를 갖는다


*함수의 매개변수에 따른 분류
1.Call by Value 	- 매개변수가 일반적인 변수인 경우(값을 넘겨준다)
2.Call by Address 	- 매개 변수가 포인터인 경우(주소를 넘겨준다)

3.Call by Reference	- 매개 변수가 참조(값)인 경우(JAVA,C#,C++ 등 객체지향언어)

*Call by Value
매개변수로 값이 포함된 일반적인 변수를 복사함으로써 값을 참조하기만 할뿐
메모리에 저장된 값 자체를 변동할 수 없다.
	참조(복사)
main변수 ----------> 함수
     └------------------┘
        리턴값 반환(복사)
       실제 값 간섭 불가
※함수에서 아무리 복사 받은 변수의 값을 바꾸더라도 반환값 외의 변경값들은 
main함수에 적용되지 않는다.
ex)
int up(int a,int b)
{
     a = a + 1;
     b = b + 1;
     return a;
}
int main()
{
     int a = 0,b = 0;
     a = plus(a,b)
}
결과: a=1,b=0
※리턴값을 참조(복사)받은 main함수 a=0 -> a = a +1을 받아 1이 되지만
리턴값을 받지 못한 main함수 b=0은 지역변수에서만 b = b +1;됬을뿐 
실제 값을 간섭받지 못하므로 여전히 b=0으로 남는다.


*Call by Address
매개변수로 변수의 주소 자체를 보내는 것으로 값을 참조할뿐 아니라
메모리에 저장된 주소 자체에 개입하여 실제값 자체를 변동할 수 있다.
	 주소값
main변수 ----------> 함수
     └------------------┘    
     실제 값(메모리) 간섭 가능
ex)
void up(int* a,int* b)
{
     *a = *a + 1;
     *b = *b + 1;
}
int main()
{
     int a = 0,b = 0;
     plus(&a,&b);
}
결과: a=1,b=1
※main함수로부터 넘겨받은 a,b함수의 주소로 메모리에 직접 개입하기 때문에
a,b 모두 함수에서 +1씩 되었지만 main함수의 a,b역시 값이 변경된다.


int sum(int* a)          
{
     return a[0] + a[1];
}

int main()
{
   int arr[] = { 100 , 200 }
   printf("result : %d\n", sum(arr));
   return 0;
}
arr배열명을 포인터(arr배열의 주소,&arr[0]의 주소)로써 매개변수로 함수에 넘겨주고
함수의 지역 포인터 변수 a에는 arr배열의 주소가 들어간다.


*함수의 리턴값은 하나만 가능하다. 따라서 배열은 리턴할 수 없다
배열을 직접 리턴할 수 없으니 배열의 주소를 리턴한다.
